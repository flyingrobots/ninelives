---
id: P2.18
title: Router wrapping with AuthZ + Audit policies
estimate: 2h
status: closed
blocked_by:
- P2.09
- P2.16b
- P2.17
blocks:
- P2.19
value: H
---
# [P2.18] Router wrapping with AuthZ + Audit policies

## Summary

Wrap the CommandRouter with AuthZ and Audit layers using standard tower Layer composition. Resolve the critical design question: should authorization denials be audited, or should audit only capture authorized commands?

**Design Decision**: **Audit-then-Authorize** - All commands are audited (including denials) for complete observability. Authorization failures are recorded in audit trail with "denied" status.

## Context

The control plane must be both secure (authorization) and observable (audit). The order of these layers affects what gets logged:

1. **Authorize-then-Audit**: Only successful commands are audited. Denials are silent.
   - Pro: Smaller audit logs, less noise
   - Con: No visibility into attacks or misconfigured clients

2. **Audit-then-Authorize (CHOSEN)**: All commands are audited, including denials.
   - Pro: Complete observability, detect unauthorized access attempts
   - Con: Larger audit logs
   - **This is the security-correct choice** ✅

## Steps

### 1. Document Layer Ordering Decision (0.5h)

Add to `docs/ADR-005-authz-audit-ordering.md`:

```markdown
# ADR-005: Authorization and Audit Layer Ordering

## Decision

We audit ALL commands (including authorization failures) before enforcing authorization.

Layer Stack:
```
Request → Audit → AuthZ → Router → Response
```

## Rationale

1. **Security**: Unauthorized access attempts must be visible for intrusion detection
2. **Compliance**: Many regulatory frameworks require logging of all access attempts
3. **Debugging**: Easier to diagnose misconfigured clients when denials are logged
4. **Consistency**: Audit trail is complete

## Implementation

The AuditSink records:
- Authorized commands with status "ok" or "error" (handler failure)
- Denied commands with status "denied" (authz failure)

## Example Audit Entry

```json
{
  "id": "cmd-123",
  "command": "WriteConfig",
  "principal": "user@example.com",
  "status": "denied",
  "reason": "insufficient permissions",
  "timestamp": 1234567890
}
```
```

### 2. Implement Layer Composition (1h)

In `src/control/router.rs`, add:

```rust
impl<C> CommandRouter<C>
where
    C: Send + Sync + Clone + CommandLabel + 'static,
{
    /// Wrap this router with authorization and audit layers
    ///
    /// Layer order: Audit → AuthZ → Router
    /// All commands (including denied) are audited.
    pub fn with_security(
        self,
        authz: Arc<dyn AuthProvider>,
        audit: Arc<dyn AuditSink>,
    ) -> SecuredRouter<C> {
        SecuredRouter {
            router: Arc::new(self),
            authz,
            audit,
        }
    }
}

/// Router wrapped with security layers
pub struct SecuredRouter<C> {
    router: Arc<CommandRouter<C>>,
    authz: Arc<dyn AuthProvider>,
    audit: Arc<dyn AuditSink>,
}

impl<C> SecuredRouter<C>
where
    C: Send + Sync + Clone + CommandLabel + 'static,
{
    pub async fn execute(&self, env: CommandEnvelope<C>) -> Result<CommandResult, CommandError> {
        // 1. AUDIT FIRST (record all attempts)
        let audit_record = AuditRecord {
            id: env.meta.id.clone(),
            label: env.cmd.label().to_string(),
            principal: "unknown".to_string(), // Will update after auth
            status: "pending".to_string(),
        };

        // 2. AUTHENTICATE
        let ctx = self.authz.authenticate(&env.meta, env.auth.as_ref())?;

        // 3. AUTHORIZE
        if let Err(e) = self.authz.authorize(&ctx, env.cmd.label(), &env.meta) {
            // DENIED - audit with status
            let denied_record = AuditRecord {
                id: env.meta.id.clone(),
                label: env.cmd.label().to_string(),
                principal: ctx.principal.clone(),
                status: format!("denied: {}", e),
            };
            self.audit.record(denied_record).await?;
            return Err(CommandError::Auth(e));
        }

        // 4. EXECUTE
        let result = self.router.execute(env.clone()).await;

        // 5. UPDATE AUDIT (success or handler failure)
        let final_record = AuditRecord {
            id: env.meta.id.clone(),
            label: env.cmd.label().to_string(),
            principal: ctx.principal,
            status: match &result {
                Ok(CommandResult::Error(e)) => format!("error: {}", e),
                Ok(_) => "ok".to_string(),
                Err(e) => format!("failed: {}", e),
            },
        };
        self.audit.record(final_record).await?;

        result
    }
}
```

### 3. Add Tests (0.5h)

```rust
#[tokio::test]
async fn denied_command_is_audited() {
    let audit = Arc::new(MemoryAuditSink::new());
    let authz = Arc::new(DenyAllAuth);
    let router = CommandRouter::new(...).with_security(authz, audit.clone());

    let cmd = CommandEnvelope {
        cmd: BuiltInCommand::Get { key: "foo".into() },
        auth: Some(AuthPayload::Opaque(vec![])),
        meta: CommandMeta { id: "cmd-1".into(), .. },
    };

    let result = router.execute(cmd).await;

    assert!(matches!(result, Err(CommandError::Auth(_))));

    let records = audit.get_records();
    assert_eq!(records.len(), 1);
    assert!(records[0].status.starts_with("denied"));
}

#[tokio::test]
async fn successful_command_is_audited() {
    let audit = Arc::new(MemoryAuditSink::new());
    let authz = Arc::new(PassthroughAuth);
    let router = CommandRouter::new(...).with_security(authz, audit.clone());

    let cmd = CommandEnvelope {
        cmd: BuiltInCommand::Get { key: "foo".into() },
        auth: Some(AuthPayload::Opaque(vec![])),
        meta: CommandMeta { id: "cmd-2".into(), .. },
    };

    let result = router.execute(cmd).await;

    assert!(result.is_ok());

    let records = audit.get_records();
    assert_eq!(records.len(), 1);
    assert_eq!(records[0].status, "ok");
}
```

## Ready When

- [x] ADR-005 documents audit-then-authorize decision with rationale
- [x] `SecuredRouter` implements audit → authz → execute flow
- [x] Denied commands are audited with "denied" status
- [x] Successful commands are audited with "ok" or "error" status
- [x] Tests validate both deny and allow paths

## Test Plan

### Unit Tests
- [x] Denied command produces audit record with "denied" status
- [x] Successful command produces audit record with "ok" status
- [x] Handler error produces audit record with "error: <msg>" status
- [x] Audit failure returns CommandError::Audit

### Integration Tests
- [x] End-to-end with PassthroughAuth + MemoryAuditSink
- [x] End-to-end with DenyAllAuth + audit records denial
- [x] Multiple commands produce multiple audit records in order

### End-to-end Tests
- N/A

## Definition of Done

1. ✅ Layer ordering decision documented in ADR-005
2. ✅ SecuredRouter implements audit-first flow
3. ✅ All commands (authorized and denied) are audited
4. ✅ Audit records include principal, status, timestamp
5. ✅ Tests validate security properties

## Edge Cases

- **Audit sink failure**: Return CommandError::Audit, command does NOT execute
- **Authentication failure**: Audit with principal="unknown", status="unauthenticated"
- **Authorization failure**: Audit with actual principal, status="denied"
- **Concurrent requests**: SecuredRouter must be Clone + Send + Sync

## Dependencies

**Requires:**
- P2.09 (CommandRouter) - Core router to wrap
- P2.16 (AuthZ layer) - AuthProvider trait
- P2.17 (Audit layer) - AuditSink trait

**Enables:**
- P2.19 (Package ninelives-control) - Complete control plane

## Notes

- Estimate increased to 2h to account for ADR writing
- GATOS integration: Audit records will be written to refs/gatos/audit/control/*
- Security-critical: This layer protects the entire control plane